using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class Avatar : MonoBehaviour, IKillable, IDamageable<float>
{
    public void Kill()
    {

    }

    public void Damage(float damageTaken)
    {

    }
}
#region 接口筆記
/*
 * Interfaces
實現接口的任何類
必須擁有其所有方法和屬性
作為交換 通過使用多態
其他類可將實現類 視作接口

需要注意的是 接口不是類 不能有自己的實例
繼承是 is a關係
即一個類繼承自另一個類

而接口使用實現關係
即一個類實現一個接口

聲明接口時 
通常對每個接口使用一個腳本
取名開頭通常I大寫
實現接口需要滿足一些需求 
也有一些好處
為了實現接口
類必須公開聲明這個接口中存在的
所有 方法 屬性 事件 索引器

如果不這樣做將導致錯誤

接口的主要優勢是
允許跨多個類定義 通用功能
因此你可以根據 類實現的接口
安全地對類的用途作出假設
要實現接口 只需在類具有的
任何繼承後方 , 放 接口名稱

如果類不是從其他類繼承過來 則不需要 ,
如果接口有 泛型類型 則名稱後要  <類型>

請注意 函數主體與接口相互獨立
可按你希望的任何方式 進行實現
用來實現 全毀全滅效果 這功能可能很有用

你可能會很好奇
既然可以在一個類中合理使用函數
並讓其他類繼承這個函數
為什麼還要在類中實現接口呢

簡單點的回答就是
你可以實現 多個接口 但不能從多個類繼承
因此通過接口 可以很好地提供泛用功能

但更好的答案是
接口用於跨多個互不相關的類
定義通用功能

考慮
兩個類Wall / Car
兩個都可破壞 但沒什麼共同特徵
    */
#endregion